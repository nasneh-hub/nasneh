name: Auto Changelog

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  update-changelog:
    name: Update Changelog
    runs-on: ubuntu-latest
    # Only run if PR was merged (not just closed)
    if: github.event.pull_request.merged == true
    
    permissions:
      contents: write
      pull-requests: read
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Update Changelog
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const prTitle = pr.title;
            const prUrl = pr.html_url;
            const mergedAt = pr.merged_at;
            
            console.log(`Processing PR #${prNumber}: ${prTitle}`);
            
            // Parse conventional commit title
            const match = prTitle.match(/^([a-z]+)(?:\(([a-z0-9-]+)\))?:\s*(.+)$/i);
            if (!match) {
              console.log('PR title does not match conventional commit format, skipping...');
              return;
            }
            
            const type = match[1].toLowerCase();
            const scope = match[2] ? match[2].toLowerCase() : null;
            const description = match[3];
            
            // Map type to emoji and category
            const typeMap = {
              'feat': { emoji: '‚ú®', category: 'Features (feat)' },
              'fix': { emoji: 'üêõ', category: 'Bug Fixes (fix)' },
              'docs': { emoji: 'üìö', category: 'Documentation (docs)' },
              'refactor': { emoji: '‚ôªÔ∏è', category: 'Refactors (refactor)' },
              'test': { emoji: 'üß™', category: 'Tests (test)' },
              'chore': { emoji: 'üîß', category: 'Chores (chore)' },
              'ci': { emoji: 'üöÄ', category: 'CI/CD (ci)' },
              'perf': { emoji: '‚ö°', category: 'Performance (perf)' },
              'build': { emoji: 'üèóÔ∏è', category: 'Build (build)' },
              'style': { emoji: 'üíÑ', category: 'Style (style)' },
              'revert': { emoji: '‚è™', category: 'Reverts (revert)' }
            };
            
            const typeInfo = typeMap[type] || { emoji: 'üìù', category: 'Other' };
            
            // Read current changelog
            const changelogPath = 'docs/CHANGELOG.md';
            let changelog = fs.readFileSync(changelogPath, 'utf8');
            
            // Create the new entry
            const scopeStr = scope ? `(${scope})` : '';
            const newEntry = `- **#${prNumber}:** ${description}`;
            
            // Find the [Unreleased] section and the appropriate category
            const categoryHeader = `### ${typeInfo.emoji} ${typeInfo.category}`;
            
            // Check if category exists in Unreleased section
            const unreleasedMatch = changelog.match(/## \[Unreleased\]([\s\S]*?)(?=\n## \[|$)/);
            
            if (unreleasedMatch) {
              let unreleasedSection = unreleasedMatch[1];
              
              // Check if category exists
              if (unreleasedSection.includes(categoryHeader)) {
                // Add entry under existing category
                const categoryRegex = new RegExp(`(${categoryHeader.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\n)`, 'g');
                changelog = changelog.replace(categoryRegex, `$1${newEntry}\n`);
              } else {
                // Add new category after [Unreleased] header
                const unreleasedHeaderRegex = /## \[Unreleased\]\n/;
                changelog = changelog.replace(
                  unreleasedHeaderRegex,
                  `## [Unreleased]\n\n${categoryHeader}\n${newEntry}\n`
                );
              }
            } else {
              // Create Unreleased section if it doesn't exist
              const firstVersionMatch = changelog.match(/## \[[\d.]+\]/);
              if (firstVersionMatch) {
                const insertPos = changelog.indexOf(firstVersionMatch[0]);
                const newSection = `## [Unreleased]\n\n${categoryHeader}\n${newEntry}\n\n---\n\n`;
                changelog = changelog.slice(0, insertPos) + newSection + changelog.slice(insertPos);
              }
            }
            
            // Write updated changelog
            fs.writeFileSync(changelogPath, changelog);
            console.log(`‚úÖ Added entry for PR #${prNumber} to CHANGELOG.md`);
            
            // Set output for commit step
            core.exportVariable('PR_NUMBER', prNumber);
            core.exportVariable('PR_TITLE', prTitle);
      
      - name: Commit Changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are changes to commit
          if git diff --quiet docs/CHANGELOG.md; then
            echo "No changes to commit"
            exit 0
          fi
          
          git add docs/CHANGELOG.md
          git commit -m "docs(changelog): auto-update for PR #$PR_NUMBER [skip ci]"
          git push
