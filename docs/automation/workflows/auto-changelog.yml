name: Auto Changelog

on:
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  update-changelog:
    name: Update Changelog
    runs-on: ubuntu-latest
    # Only run if PR was merged (not just closed)
    if: github.event.pull_request.merged == true
    
    steps:
      - name: Generate App Token
        uses: actions/create-github-app-token@v2
        id: app-token
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}
          ref: main
      
      - name: Update Changelog
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const prTitle = pr.title;
            const prUrl = pr.html_url;
            const mergedAt = pr.merged_at;
            
            console.log(`Processing PR #${prNumber}: ${prTitle}`);
            
            // Parse conventional commit title
            const match = prTitle.match(/^([a-z]+)(?:\(([a-z0-9-]+)\))?:\s*(.+)$/i);
            if (!match) {
              console.log('PR title does not match conventional commit format, skipping...');
              return;
            }
            
            const type = match[1].toLowerCase();
            const scope = match[2] ? match[2].toLowerCase() : null;
            const description = match[3];
            
            // Map type to emoji and category
            const typeMap = {
              'feat': { emoji: 'âœ¨', category: 'Features (feat)' },
              'fix': { emoji: 'ðŸ›', category: 'Bug Fixes (fix)' },
              'docs': { emoji: 'ðŸ“š', category: 'Documentation (docs)' },
              'refactor': { emoji: 'â™»ï¸', category: 'Refactors (refactor)' },
              'test': { emoji: 'ðŸ§ª', category: 'Tests (test)' },
              'chore': { emoji: 'ðŸ”§', category: 'Chores (chore)' },
              'ci': { emoji: 'ðŸš€', category: 'CI/CD (ci)' },
              'perf': { emoji: 'âš¡', category: 'Performance (perf)' },
              'build': { emoji: 'ðŸ—ï¸', category: 'Build (build)' },
              'style': { emoji: 'ðŸ’„', category: 'Style (style)' },
              'revert': { emoji: 'âª', category: 'Reverts (revert)' }
            };
            
            const typeInfo = typeMap[type] || { emoji: 'ðŸ“', category: 'Other' };
            
            // Read current changelog
            const changelogPath = 'docs/CHANGELOG.md';
            let changelog = fs.readFileSync(changelogPath, 'utf8');
            
            // Create the new entry
            const scopeStr = scope ? `(${scope})` : '';
            const newEntry = `- **#${prNumber}:** ${description}`;
            
            // Find the [Unreleased] section and the appropriate category
            const categoryHeader = `### ${typeInfo.emoji} ${typeInfo.category}`;
            
            // Check if category exists in Unreleased section
            const unreleasedMatch = changelog.match(/## \[Unreleased\]([\s\S]*?)(?=\n## \[|$)/);
            
            if (unreleasedMatch) {
              let unreleasedSection = unreleasedMatch[1];
              
              // Check if category exists
              if (unreleasedSection.includes(categoryHeader)) {
                // Add entry under existing category
                const categoryRegex = new RegExp(`(${categoryHeader.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\n)`, 'g');
                changelog = changelog.replace(categoryRegex, `$1${newEntry}\n`);
              } else {
                // Add new category after [Unreleased] header
                const unreleasedHeaderRegex = /## \[Unreleased\]\n/;
                changelog = changelog.replace(
                  unreleasedHeaderRegex,
                  `## [Unreleased]\n\n${categoryHeader}\n${newEntry}\n`
                );
              }
            } else {
              // Create Unreleased section if it doesn't exist
              const firstVersionMatch = changelog.match(/## \[[\d.]+\]/);
              if (firstVersionMatch) {
                const insertPos = changelog.indexOf(firstVersionMatch[0]);
                const newSection = `## [Unreleased]\n\n${categoryHeader}\n${newEntry}\n\n---\n\n`;
                changelog = changelog.slice(0, insertPos) + newSection + changelog.slice(insertPos);
              }
            }
            
            // Write updated changelog
            fs.writeFileSync(changelogPath, changelog);
            console.log(`âœ… Added entry for PR #${prNumber} to CHANGELOG.md`);
            
            // Set output for commit step
            core.exportVariable('PR_NUMBER', prNumber);
            core.exportVariable('PR_TITLE', prTitle);
      
      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Commit Changes
        run: |
          git config --local user.name "${{ steps.app-token.outputs.app-slug }}[bot]"
          git config --local user.email "${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com"
          
          # Check if there are changes to commit
          if git diff --quiet docs/CHANGELOG.md; then
            echo "No changes to commit"
            exit 0
          fi
          
          git add docs/CHANGELOG.md
          git commit -m "docs(changelog): auto-update for PR #$PR_NUMBER [skip ci]"
          git push
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
